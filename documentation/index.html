<!-- steps to put on blogger:
-remove head and body tag

-replace all image links:
--replace src='../sample_images/ by src='http://vaserenderer.sourceforge.net/blog/vaserendererdraft12/

-replace href='line_segment/line_segment.html' by href='http://artgrammer.blogspot.com/2011/05/drawing-nearly-perfect-2d-line-segments.html'

-replace href='polyline/polyline.html' by href='http://artgrammer.blogspot.com/2011/07/drawing-polylines-by-tessellation.html'
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<head>
	<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
	<div class='vaser_wrap'>
		<div class='article_name'>
			<h1>Vase Renderer<img src='../sample_images/V.png' height=80 /></h1>
			first draft, version 0.25 (VaseR draft1_2)
		</div>
		<h2>About</h2>
<p>Vase renderer(VaseR) is a 2D graphics renderer built on top of OpenGL. Unlike most graphics libraries
 which are based on <code>SetPixel()</code>, VaseR is based on <code>glDrawArrays()</code>.
 That means, VaseR takes the advantage of GPU rasterization. Another unique feature of VaseR is rendering
 with premium quality anti- aliasing using 'fade polygons', as mentioned in
 <a href='http://artgrammer.blogspot.com/2011/05/drawing-nearly-perfect-2d-line-segments.html' target="_blank">
this article</a>.
</p>


		<h2>Getting started</h2>
<p>To properly use VaseR, you need to understand what role does VaseR play in the rendering pipeline. Suppose your application has a 2D rendering pipeline like:
</p>
<table>
<tr>	<td>model transformation</td></tr>
<tr>	<td>clippings</td></tr>
<tr>	<td>view transformation</td></tr>

<tr class='box_redlight'>
	<td>primitives generation<br />
		i.e.
		<code>glDrawArrays();</code>
		<br /><b>and/or</b>
		<code>glBegin(); glEnd();</code>
	</td>
</tr>

<tr>	<td>OpenGL pipeline...</td></tr>
</table>
<p>VaseR is a renderer and merely takes care the primitives generation part (highlighted in red). You should set the gl states to meet VaseR's requirements before calling any VaseR function:
<table class='api_table'>
	<tr><td>blending</td><td><pre lang="C++">glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</pre></td>
	</tr>
	<tr><td>vertex array <br />client states</td><td><pre lang="C++">glEnableClientState(GL_VERTEX_ARRAY);
glEnableClientState(GL_COLOR_ARRAY);

glDisableClientState(GL_EDGE_FLAG_ARRAY);
glDisableClientState(GL_FOG_COORD_ARRAY);
glDisableClientState(GL_INDEX_ARRAY);
glDisableClientState(GL_NORMAL_ARRAY);
glDisableClientState(GL_SECONDARY_COLOR_ARRAY);
glDisableClientState(GL_TEXTURE_COORD_ARRAY);</pre></td>
	</tr>
	<tr><td>other</td><td>gl's default<br />important: no back face culling</td>
	</tr>
</table>
</p>

<div class='box_tips'>
Beginners' tips: <a onclick='box_tips_switchsize(this)'>hide</a><br />
How to correctly set gl states for VaseR..
<p>Suppose you have a helloworld application that only renders a line segment in draw():</p>
<pre lang="C++">
void draw()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
		glLoadIdentity();
		glOrtho( 0,context_width,context_height,0,0.0f,100.0f);
		<b>glLineWidth(2.0);
		glBegin(GL_LINES);
			glColor4f(1,0,0.5, 1);
			glVertex2f(10,100);
			glColor4f(0.5,0,1, 1);
			glVertex2f(100,300);
		glEnd();
		//other drawings</b>
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
}</pre>
extend it into:
<pre lang="C++">
void draw()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			glLoadIdentity();
			glOrtho( 0,context_width,context_height,0,0.0f,100.0f);

			glEnableClientState(GL_VERTEX_ARRAY);
			glEnableClientState(GL_COLOR_ARRAY);
				<b>{	Vec2  P1 = {10,100};
					Vec2  P2 = {100,300};
					Color C1 = {1,0,0.5, 1};
					Color C2 = {0.5,0,1, 1};
					double W1= 2.0;
					double W2= W1;
					
					segment(P1,P2, C1,C2, W1,W2, 0);
				}
				//other VaseR calls</b>
			glDisableClientState(GL_VERTEX_ARRAY);
			glDisableClientState(GL_COLOR_ARRAY);

			//other drawings with blending
		glDisable(GL_BLEND); //restore blending options
		
		//other drawings without blending
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
}</pre>
</div> <!--class='box_tips' -->

			<h3>Usage</h3>
<p>Provide these structs to VaseR <b>before</b> any vase_renderer_* include by:<br />
<pre lang="C++">
struct Vec2 { double x,y;};
struct Color { float r,g,b,a;};
<b>or</b>
typedef your_vec2 Vec2;
typedef your_color Color;

#include "../include/vase_renderer_draft1_2.cpp"</pre>
</p>

<p>The recommended way is to include "vase_renderer_draft1_2.cpp" .</p>
<p>You should not include "vector_operations.h" or "vertex_array_holder.h" directly. It may break things. They are included by "vase_renderer_draft1_2.cpp".</p>
<p>To compile "vase_renderer_draft1_2.cpp" separately, create an empty cpp file to provide the structs:</p>
<pre lang="C++">//file vase_renderer.cpp
	struct Vec2 { double x,y;};
	struct Color { float r,g,b,a;};
	#include "vase_renderer_draft1_2.cpp"
//end of file</pre>


		<h2>Documentation</h2>
			<h3>API design</h3>
<p>VaseR has no states, only a set of functions. Thus you need to pass many parameters to a VaseR function on each call. And these parameters are stored in structures like WinAPI does. Normally if you do not know what options to set, just put <code>0</code> at the parameter <code>polyline_opt*</code>. VaseR ensures empty parameter <code>polyline_opt* options=0</code> <b>and</b> empty structure <code>polyline_opt opt={0};</code> are default options and would not cause any error.
</p>

<table class='api_table' style='width:100%;'>
	
	<tr><td>
		<h3>polyline()</h3>
	For technical details about polyline() <a href='http://artgrammer.blogspot.com/2011/07/drawing-polylines-by-tessellation.html' target='_blank'>look at here</a>.
		<pre lang="C++">void polyline(
	Vec2* P,       //array of point of a polyline
	Color* C,      //array of color
	double* weight,//array of weight
	int size_of_P, //size of the buffers
	polyline_opt* options); //extra options</pre>
	All arrays must be of the same size otherwise memory error will occur.
		<h4>options</h4>
		<pre lang="C++">struct polyline_opt
{	//set the whole structure to 0 will give default options
	char joint;
		#define LJ_miter 0
		#define LJ_bevel 1
		#define LJ_round 2
	char cap;
		#define LC_butt   0
		#define LC_round  1
		#define LC_square 2
		#define LC_rect   3 //unique to vase renderer
	bool feather;
		double feathering;
		bool no_feather_at_cap;
		bool no_feather_at_core;
};</pre>
	
	<code>polyline_opt opt={0}; //consider this structure: <br /><br />
		<table>
			<caption>opt.joint</caption>
			<tr>	<td>LJ_miter<img src='../sample_images/polyline_joint_LJ_miter.png' /></td>
				<td>LJ_bevel<img src='../sample_images/polyline_joint_LJ_bevel.png' /></td>
				<td>LJ_round<img src='../sample_images/polyline_joint_LJ_round.png' /></td>
			</tr>
		</table>
		<br />
		<table>
			<caption>opt.cap</caption>
			<tr>	<td>LC_butt  <img src='../sample_images/polyline_cap_LC_butt.png' /></td>
				<td>LC_round <img src='../sample_images/polyline_cap_LC_round.png' /></td>
				<td>LC_square<img src='../sample_images/polyline_cap_LC_square.png' /></td>
			</tr>
			<tr>
				<td colspan=10>LC_rect<br />
				LC_rect is related to feathering. Unlike the above 3 common cap types, LC_rect is unique
		to VaseR. LC_rect puts the fade polygon out of the end points of a 
		polyline.<br />When feather=false, LC_rect looks very close to LC_butt. The difference is only obvious
		 at high value of feathering.
				</td>
			</tr>
			<tr>
				<td>LC_rect (with high value of feathering)<img src='../sample_images/polyline_cap_LC_rect.png' /></td>
				<td>LC_butt (with high value of feathering)<img src='../sample_images/polyline_cap_LC_butt_high_feathering.png' /></td>
			</tr>
		</table>
		<br />
		<table>
			<caption>opt.feather, opt.feathering, opt.no_feather_at_cap, opt.no_feather_at_core</caption>
		<tr>		<td> feathering is a multiplier to the magnitude of the fade polygon.
		do not set it to lower than 1.0 .<br />
		feathering is unique to VaseR. A feathered polyline with round cap and round joint can mimic
		the feel of an air brush stroke.
				</td>
				<td><img src='../sample_images/polyline_mimic_airbrush.png'/></td>
		</tr>
		</table>
		<table>
			<tr>	
				<td>opt.feather = false;<br /><img src='../sample_images/polyline_joint_LJ_miter.png' /></td>
				
				<td>opt.feather = true;<br />opt.feathering = 8.0;<br />
				<img src='../sample_images/polyline_feathering_8.png' />
				</td>
			</tr>
			<tr>
				<td>opt.feather = true;<br />
				opt.feathering = 8.0;<br />
				opt.no_feather_at_cap = true;<br />
				opt.no_feather_at_core = false;<br />
				<img src='../sample_images/polyline_no_feather_at_cap.png' />
				</td>
				
				<td>opt.feather = true;<br />
				opt.feathering = 8.0;<br />
				opt.no_feather_at_cap = false;<br />
				opt.no_feather_at_core = true;<br />
				<img src='../sample_images/polyline_no_feather_at_core.png' />
				</td>
			</tr>
			<tr>	<td colspan=10>
				remarks: no_feather_at_cap only affects cap type LC_butt,
				LC_square and LC_rect .
				</td>
			</tr>
		</table>
		<br />
	</code>
		<h4>Usage</h4>
	<img src='../sample_images/polyline.png' style='float:right'/>
		<pre lang="C++">
void sample_polyline()
{
	int size_of_AP=4;
	Vec2 AP[size_of_AP];
		AP[0].x=200; AP[0].y=50;
		AP[1].x=100; AP[1].y=150;
		AP[2].x=300; AP[2].y=150;
		AP[3].x=200; AP[3].y=250;
	Color AC[size_of_AP];
		{ Color col={1 , 0, 0, 1}; cc[0]=col;}
		{ Color col={.8,.8, 0, 1}; cc[1]=col;}
		{ Color col={ 0, 0, 1, 1}; cc[2]=col;}
		{ Color col={1 , 0, 0, 1}; cc[3]=col;}
	double Aw[size_of_AP];
		Aw[0] = 8.0;
		Aw[1] = 8.0;
		Aw[2] = 8.0;
		Aw[3] = 8.0;
	
	polyline_opt opt={0};
	polyline( AP, AC, Aw, size_of_AP, &opt);
}</pre>
example program is at <code>samples/polyline</code> under VaseR package.

			<h4>Notes</h4>
Varying color is stable but will cause overdraw at degenerated cases.<br />
Varying weight is unstable.<br />
polyline() will "go wild" when a segment is shorter than its own width.<br />

			<h4>Further work</h4>
After solving the above 3 mentioned problems,<br />
can provide the choice between color blending profiles, possibly 'hard' and 'soft'.
	</td></tr><!--polyline-->
	
	<tr><td>
		<h3>segment()</h3>
		<pre lang="C++">
void segment(  const Vec2& P1, const Vec2& P2, //coordinates
        const Color& C1, const Color& C2,      //colors
        double W1, double W2,                  //weights
        const polyline_opt* options)           //extra options
{
	Vec2   AP[2];
	Color  AC[2];
	double AW[2];
		AP[0] = P1; AC[0] = C1; AW[0] = W1;
		AP[1] = P2; AC[1] = C2; AW[1] = W2;
	polyline( AP, AC, AW, 2, options);
}</pre>
	segment() is merely a wrapper over polyline() , thus all options of segment() is the same as polyline().
			<h4>Usage</h4>
			<pre lang="C++">
void sample_spectrum()
{
	for ( int i=0; i < 20; i++)
	{
		Vec2  P1 = { 5+29.7*i, 187};
		Vec2  P2 = { 35+29.7*i, 8};
		Color C1 = { 1.0,0.0,0.5, 1.0};
		Color C2 = { 0.5,0.0,1.0, 1.0};
		double W1= 0.3*(i+1);
		double W2= W1;
		
		segment(P1,P2, C1,C2, W1,W2, 0);
	}
}

void sample_radial_spectrum()
{
	for ( double ag=0, i=0; ag < 2*vaserend_pi-0.1; ag+=vaserend_pi/12, i+=1)
	{
		double r1 = 30.0;
		double r2 = 90.0;
		
		double tx2=r2*cos(ag);
		double ty2=r2*sin(ag);
		double tx1=r1*cos(ag);
		double ty1=r1*sin(ag);
		double Ox = 120;
		double Oy = 194+97;
		
		Vec2  P1 = { Ox+tx1,Oy-ty1};
		Vec2  P2 = { Ox+tx2,Oy-ty2};
		Color C1 = { 1.0,0.0,0.5, 1.0};
		Color C2 = { 0.5,0.0,1.0, 1.0};
		double W1= 0.3*(i+1);
		double W2= W1;
		
		segment(P1,P2, C1,C2, W1,W2, 0);
	}
}</pre>
	example program is at <code>samples/segment</code> under VaseR package. In the below spectrums, each segment is 0.3 pixel thicker/ heavier than the previous segment, demonstrating sub- pixel accuracy of VaseR.
	<img src='../sample_images/segment.png'/>
	</td></tr><!--segment-->

</table><!--table of API-->

		<h3>Source code</h3>
Development package with documentation, source code, sample images and sample programs is at sourceforge:
<a href='http://sourceforge.net/projects/vaserenderer/files/draft_release/July2011/VaseR-draft1_2.zip/download' target='_blank'>current stable release</a> or <a href='http://vaserenderer.git.sourceforge.net/git/gitweb.cgi?p=vaserenderer/vaserenderer;a=summary' target='_blank'>git source tree</a>.

		<h3>Credit and license</h3>
<p>Current maintainer and copyright holder is Chris Tsang, tyt2y3@gmail.com<br />
Comments, discussions, and contributions are greatly appreciated.
</p>
<p>The license terms at this version "Vase Renderer first draft, version 0.25 (draft1_2)" are:<br />
If you used Vase Renderer (abbreviated as VaseR )in your program or produced derived work of VaseR, you should include a notice along with the distribution of your work describing how you used VaseR.<br />
No extra restriction on commercial use. No warranty provided.
</p>
	</div> <!--<div id='wrap'>-->
	
<script>
function getElementsByClass(searchClass,node,tag)
{	//http://www.dustindiaz.com/getelementsbyclass
	//also very good!
	//http://www.dustindiaz.com/javascript-animate
	var classElements = new Array();
	if ( node == null )
		node = document;
	if ( tag == null )
		tag = '*';
	var els = node.getElementsByTagName(tag);
	var elsLen = els.length;
	var pattern = new RegExp("(^|\\s)"+searchClass+"(\\s|$)");
	
	for (i = 0, j = 0; i < elsLen; i++) {
		if ( pattern.test(els[i].className) ) {
			classElements[j] = els[i];
			j++;
		}
	}
	return classElements;
}
{	//init
	var tips_list = getElementsByClass('box_tips',null,'div');
	for ( var i=0; i<tips_list.length; i++)
	{
		var a_list = tips_list[i].getElementsByTagName('a');
		if ( a_list.length > 0)
		{
			var instr = a_list[0].innerHTML;
			if ( instr.length==4)
				if ( instr=='hide')
					box_tips_switchsize( a_list[0]);
		}
	}
}
function box_tips_switchsize(obj)
{
	if ( obj.innerHTML[0]=='s')
	{	//show the box tips
		obj.parentNode.style.height='auto';
		obj.innerHTML='hide';
	}
	else
	{	//hide it
		obj.parentNode.style.height='60px';
		obj.innerHTML='show';
	}
}
</script>
</body>
